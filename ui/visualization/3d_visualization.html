<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LEXARA - 3D Topic Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            overflow: hidden;
        }

        #container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            color: #ffffff;
            max-width: 300px;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #info-panel h2 {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #64b5f6;
        }

        #info-panel p {
            font-size: 0.9rem;
            line-height: 1.5;
            opacity: 0.9;
        }

        #topic-title {
            font-weight: 600;
            color: #81c784;
            margin-top: 10px;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #ffffff;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        .control-btn.active {
            background: #2196F3;
            border-color: #2196F3;
        }

        #timeline-bar {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            z-index: 100;
        }

        #timeline-progress {
            height: 100%;
            background: linear-gradient(90deg, #2196F3, #4CAF50);
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 1.2rem;
            z-index: 1000;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="loading">Loading 3D Visualization...</div>

        <div id="info-panel" class="hidden">
            <h2>ðŸ“Š Topic Visualization</h2>
            <p>Hover over nodes to see topic details.</p>
            <p id="topic-title"></p>
            <p id="topic-time"></p>
        </div>

        <div id="timeline-bar" class="hidden">
            <div id="timeline-progress"></div>
        </div>

        <div id="controls" class="hidden">
            <button class="control-btn" id="btn-rotate">ðŸ”„ Auto Rotate</button>
            <button class="control-btn" id="btn-reset">ðŸ”ƒ Reset View</button>
            <button class="control-btn" id="btn-zoom-in">âž• Zoom In</button>
            <button class="control-btn" id="btn-zoom-out">âž– Zoom Out</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // LEXARA 3D Visualization

        let scene, camera, renderer, controls;
        let nodes = [];
        let lines = [];
        let animationData = [];
        let autoRotate = true;
        let hoveredNode = null;

        // Raycaster for mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Initialize Three.js scene
        function init() {
            const container = document.getElementById('container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(8, 4, 8);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x4fc3f7, 0.5);
            pointLight.position.set(-5, 5, -5);
            scene.add(pointLight);

            // Grid helper for reference
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            gridHelper.position.y = -1;
            scene.add(gridHelper);

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            container.addEventListener('mousemove', onMouseMove);

            // Control buttons
            document.getElementById('btn-rotate').addEventListener('click', toggleRotate);
            document.getElementById('btn-reset').addEventListener('click', resetView);
            document.getElementById('btn-zoom-in').addEventListener('click', zoomIn);
            document.getElementById('btn-zoom-out').addEventListener('click', zoomOut);

            // Load animation data from parent or use sample
            loadAnimationData();
        }

        function loadAnimationData() {
            // Check if data is passed from parent (Streamlit iframe)
            if (window.animationData) {
                animationData = window.animationData;
                createVisualization();
            } else {
                // Sample data for standalone testing
                animationData = [
                    {
                        Segment_ID: "seg_001",
                        Animation_Type: "intro",
                        Animation_State: "active",
                        Sync_Timestamp: 0,
                        Visual_Metadata: {
                            node_color: "#2196F3",
                            node_size: 1.2,
                            position: { x: 2.12, y: 0, z: 2.12 },
                            connections: [],
                            duration: 120
                        }
                    },
                    {
                        Segment_ID: "seg_002",
                        Animation_Type: "topic_transition",
                        Animation_State: "active",
                        Sync_Timestamp: 120,
                        Visual_Metadata: {
                            node_color: "#4CAF50",
                            node_size: 1.0,
                            position: { x: 0, y: 0.5, z: 3.3 },
                            connections: ["seg_001"],
                            duration: 180
                        }
                    },
                    {
                        Segment_ID: "seg_003",
                        Animation_Type: "topic_transition",
                        Animation_State: "active",
                        Sync_Timestamp: 300,
                        Visual_Metadata: {
                            node_color: "#FF9800",
                            node_size: 1.5,
                            position: { x: -2.54, y: 1, z: 2.54 },
                            connections: ["seg_002"],
                            duration: 240
                        }
                    },
                    {
                        Segment_ID: "seg_004",
                        Animation_Type: "outro",
                        Animation_State: "active",
                        Sync_Timestamp: 540,
                        Visual_Metadata: {
                            node_color: "#9C27B0",
                            node_size: 0.8,
                            position: { x: -3.6, y: 1.5, z: 0 },
                            connections: ["seg_003"],
                            duration: 60
                        }
                    }
                ];
                createVisualization();
            }
        }

        function createVisualization() {
            // Hide loading, show controls
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('info-panel').classList.remove('hidden');
            document.getElementById('controls').classList.remove('hidden');
            document.getElementById('timeline-bar').classList.remove('hidden');

            // Create nodes
            animationData.forEach((data, index) => {
                const meta = data.Visual_Metadata;

                // Node geometry
                const geometry = new THREE.SphereGeometry(0.3 * meta.node_size, 32, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: meta.node_color,
                    emissive: meta.node_color,
                    emissiveIntensity: 0.3,
                    shininess: 80
                });

                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(meta.position.x, meta.position.y, meta.position.z);
                sphere.userData = {
                    segmentId: data.Segment_ID,
                    type: data.Animation_Type,
                    timestamp: data.Sync_Timestamp,
                    duration: meta.duration,
                    color: meta.node_color
                };

                scene.add(sphere);
                nodes.push(sphere);

                // Create glow effect
                const glowGeometry = new THREE.SphereGeometry(0.35 * meta.node_size, 32, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: meta.node_color,
                    transparent: true,
                    opacity: 0.2
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(sphere.position);
                scene.add(glow);

                // Create connection line to previous node
                if (meta.connections.length > 0) {
                    const prevIndex = animationData.findIndex(d => d.Segment_ID === meta.connections[0]);
                    if (prevIndex >= 0) {
                        const prevMeta = animationData[prevIndex].Visual_Metadata;
                        const points = [
                            new THREE.Vector3(prevMeta.position.x, prevMeta.position.y, prevMeta.position.z),
                            new THREE.Vector3(meta.position.x, meta.position.y, meta.position.z)
                        ];

                        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        const lineMaterial = new THREE.LineBasicMaterial({
                            color: 0x64b5f6,
                            opacity: 0.6,
                            transparent: true
                        });
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        scene.add(line);
                        lines.push(line);
                    }
                }

                // Add label
                createLabel(data.Segment_ID, meta.position);
            });

            animate();
        }

        function createLabel(text, position) {
            // Create a sprite for the label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 64;

            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.font = 'Bold 24px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text.replace('seg_', 'T'), canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(position.x, position.y + 0.7, position.z);
            sprite.scale.set(0.8, 0.4, 1);
            scene.add(sprite);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodes);

            if (intersects.length > 0) {
                const node = intersects[0].object;
                if (hoveredNode !== node) {
                    if (hoveredNode) {
                        hoveredNode.material.emissiveIntensity = 0.3;
                    }
                    hoveredNode = node;
                    hoveredNode.material.emissiveIntensity = 0.8;

                    // Update info panel
                    const data = node.userData;
                    document.getElementById('topic-title').textContent =
                        `Topic: ${data.segmentId} (${data.type})`;
                    document.getElementById('topic-time').textContent =
                        `Time: ${formatTime(data.timestamp)} - Duration: ${formatTime(data.duration)}`;
                }
            } else {
                if (hoveredNode) {
                    hoveredNode.material.emissiveIntensity = 0.3;
                    hoveredNode = null;
                }
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function toggleRotate() {
            autoRotate = !autoRotate;
            document.getElementById('btn-rotate').classList.toggle('active', autoRotate);
        }

        function resetView() {
            camera.position.set(8, 4, 8);
            camera.lookAt(0, 0, 0);
        }

        function zoomIn() {
            camera.position.multiplyScalar(0.8);
        }

        function zoomOut() {
            camera.position.multiplyScalar(1.2);
        }

        let time = 0;
        function animate() {
            requestAnimationFrame(animate);

            time += 0.01;

            // Auto rotate camera
            if (autoRotate) {
                camera.position.x = 8 * Math.cos(time * 0.3);
                camera.position.z = 8 * Math.sin(time * 0.3);
                camera.lookAt(0, 1, 0);
            }

            // Animate nodes with subtle pulse
            nodes.forEach((node, i) => {
                const scale = 1 + 0.05 * Math.sin(time * 2 + i);
                node.scale.set(scale, scale, scale);
            });

            renderer.render(scene, camera);
        }

        // Message handler for Streamlit integration
        window.addEventListener('message', function (event) {
            if (event.data && event.data.type === 'animationData') {
                animationData = event.data.data;
                // Clear existing visualization
                nodes.forEach(n => scene.remove(n));
                lines.forEach(l => scene.remove(l));
                nodes = [];
                lines = [];
                createVisualization();
            }

            if (event.data && event.data.type === 'updateProgress') {
                const progress = event.data.progress;
                document.getElementById('timeline-progress').style.width = `${progress}%`;
            }
        });

        // Initialize on load
        window.onload = init;
    </script>
</body>

</html>